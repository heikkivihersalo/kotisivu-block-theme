import { readFileSync, writeFileSync, existsSync, unlinkSync } from 'fs';
import { resolve, dirname, basename } from 'path';
import { glob } from 'glob';
import { BLOCK_PATTERNS, WORDPRESS_FILE_OUTPUT } from '../../constants.js';

/**
 * Create individual editor CSS files for blocks that have editor styles
 * @param {Object} options - Build options
 * @param {Object} bundle - Bundle information
 * @param {string} outputDir - Output directory
 */
export function splitEditorCSS(options, bundle, outputDir) {
	console.log('ðŸ“ Creating individual editor CSS files for blocks...');

	// Find all blocks that have index.js files (indicating they have editor functionality)
	const blocksWithIndexFiles = findBlocksWithIndexFiles(outputDir);

	if (blocksWithIndexFiles.length === 0) {
		console.log(
			'ðŸ“ No blocks with index files found, skipping CSS creation'
		);
		return;
	}

	// Create individual index.css files for blocks that have editor.css in source
	const processedBlocks = [];

	blocksWithIndexFiles.forEach(({ blockDir, blockName, relativePath }) => {
		// Extract block-specific CSS from the source editor.css file
		const blockCSS = extractBlockSpecificCSS(
			blockDir,
			blockName,
			relativePath
		);

		if (blockCSS && blockCSS.trim().length > 0) {
			// Write individual index.css file with only this block's styles
			const indexCSSPath = resolve(
				blockDir,
				WORDPRESS_FILE_OUTPUT.EDITOR_CSS
			);
			writeFileSync(indexCSSPath, blockCSS);
			console.log(
				`ðŸ“„ Created: ${relativePath}/${WORDPRESS_FILE_OUTPUT.EDITOR_CSS}`
			);
			processedBlocks.push(blockName);
		}
	});

	if (processedBlocks.length > 0) {
		console.log(
			`âœ… Created editor CSS files for ${processedBlocks.length} blocks`
		);
	}

	// Clean up unwanted root-level CSS files generated by Vite
	cleanupRootLevelCSS(outputDir);
}

/**
 * Find all blocks that have index files (indicating editor functionality)
 * @param {string} outputDir - Output directory
 * @returns {Array} Array of block information
 */
function findBlocksWithIndexFiles(outputDir) {
	const blocks = [];

	// Find all index.js files in the build output
	const indexFiles = glob.sync(`${outputDir}/**/index.js`);

	indexFiles.forEach((indexFilePath) => {
		const blockDir = dirname(indexFilePath);
		const blockName = basename(blockDir);
		const relativePath = blockDir.replace(outputDir + '/', '');

		blocks.push({
			blockDir,
			blockName,
			relativePath,
			indexFilePath,
		});
	});

	return blocks;
}

/**
 * Extract CSS for a specific block from the edit.js import
 * This function attempts to extract only the CSS that belongs to a specific block
 * @param {string} blockDir - Block directory path
 * @param {string} blockName - Block name
 * @param {string} relativePath - Relative path to the block
 * @returns {string|null} Extracted CSS for the block or null if not found
 */
function extractBlockSpecificCSS(blockDir, blockName, relativePath) {
	// Get the current working directory to build the source path correctly
	const cwd = process.cwd();

	// Handle the different source path mappings based on the build configuration
	let sourceBlockDir;

	if (relativePath.startsWith('block-library/')) {
		// block-library/* maps to resources/widgets/block-library/custom/*
		const blockPath = relativePath.replace('block-library/', '');
		sourceBlockDir = resolve(
			cwd,
			'resources/widgets/block-library/custom',
			blockPath
		);
	} else {
		// Other paths map directly
		sourceBlockDir = resolve(cwd, 'resources/widgets', relativePath);
	}

	const editorCSSPath = resolve(sourceBlockDir, 'editor.css');

	if (existsSync(editorCSSPath)) {
		try {
			const blockSpecificCSS = readFileSync(editorCSSPath, 'utf8');
			if (blockSpecificCSS.trim().length > 0) {
				return blockSpecificCSS;
			}
		} catch (error) {
			console.warn(
				`âš ï¸  Could not read editor.css for ${relativePath}:`,
				error.message
			);
		}
	}

	return null;
}

/**
 * Clean up unwanted root-level CSS files generated by Vite
 * @param {string} outputDir - Output directory
 */
function cleanupRootLevelCSS(outputDir) {
	console.log('ðŸ§¹ Cleaning up unwanted root-level CSS files...');

	// Find all root-level CSS files that match the pattern index*.css
	const rootCSSFiles = glob.sync(`${outputDir}/index*.css`);

	let cleanedCount = 0;
	rootCSSFiles.forEach((filePath) => {
		try {
			unlinkSync(filePath);
			const fileName = basename(filePath);
			console.log(`ðŸ—‘ï¸  Removed unwanted CSS file: ${fileName}`);
			cleanedCount++;
		} catch (error) {
			console.warn(
				`âš ï¸  Could not remove CSS file ${basename(filePath)}:`,
				error.message
			);
		}
	});

	if (cleanedCount > 0) {
		console.log(`âœ… Cleaned up ${cleanedCount} unwanted CSS files`);
	}
}
